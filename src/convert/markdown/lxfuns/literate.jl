#=
NOTE:

we use the Literate convention here with quadruple backticks (this was introduced
in v2.9 which is the minimal version allowed).
=#

"""
    \\literate{rpath}

Try to find a literate file, resolve it and return it.

## Notes

1. the `rpath` is assumed to be relative to the `_literate` folder provided
    there is a `_literate` folder. (Same behaviour as `{{insert ..}}` with respect
    to the `_layout` folder)
2. if there is no `_literate` folder, the `rpath` is taken to be relative to
    the website folder
3. the `rpath` must end with `.jl` and must not start with a `/`
4. it is recommended to have a `_literate` folder to not have files flying around.
"""
function lx_literate(p::VS; tohtml::Bool=true)::String
    c = _lx_check_nargs(:literate, p, 1)
    isempty(c) || return c
    rpath = unixify(strip(p[1]))
    if !endswith(rpath, ".jl")
        @warn """
            \\literate{...}
            The relative path '$rpath' does not end with '.jl'.
            """
        return failed_lxc("literate", p)
    end

    # try to form the full path to the literate file and check it's there
    fpath = ""
    if isdir(path(:literate))
        fpath = path(:literate) / rpath
    else
        fpath = path(:folder) / rpath
    end
    if !isfile(fpath)
        @warn """
            \\literate{...}
            Couldn't find a literate file at path '$fpath' (resolved
            from '$rpath').
            """
        return failed_lxc("literate", p)
    end

    # here fpath is the full path to an existing literate script
    return _process_literate_file(rpath, fpath)
end


const LITERATE_FENCER        = "julialit"
const LITERATE_JULIA_FENCE   = "````$LITERATE_FENCER"
const LITERATE_JULIA_FENCE_L = length(LITERATE_JULIA_FENCE)
const LITERATE_JULIA_FENCE_R = Regex(LITERATE_JULIA_FENCE)


"""
    _process_literate_file(rpath, fpath)

Helper function to process a literate file located at `fpath`.
"""
function _process_literate_file(rpath::String, fpath::String)::String
    # check if Literate.jl is loaded, otherwise interrupt
    if !env(:literate)
        if (:Literate âˆ‰ names(cur_utils_module(), imported=true))
            @warn """
                \\literate{...}
                It looks like you have not imported Literate in your Utils.
                Add 'using Literate' or 'import Literate' in your utils.jl.
                """
            return failed_lxc("literate", p)
        else
            setenv!(:literate, true)
        end
    end
    L = cur_utils_module().Literate

    # check the version
    literate_toml    = (pathof(L) |> dirname  |> dirname) / "Project.toml"
    literate_version = VersionNumber(
                            TOML.parsefile(literate_toml)["version"])
    if !(v"2.9" <= literate_version)
        @warn """
            \\literate{...}
            It looks like you're using a version of Literate that's older than
            v2.9. Please update your version of Literate.
            """
        return failed_lxc("literate", p)
    end

    lc = cur_lc()
    gc = lc.glob
    gc.vars[:_literate_hashes][rpath] = hash(read(fpath, String))

    # Disable the logging
    pre_log_level = Base.CoreLogging._min_enabled_level[]
    Logging.disable_logging(Logging.Warn)

    # output the markdown (this is a reasonably safe operation which
    # shouldn't fail, it's just writing a file with some modifiers.
    ofile = L.markdown(
        fpath, mktempdir();
        flavor      = L.FranklinFlavor(),
        mdstrings   = getvar(lc, :literate_mdstrings, false),
        config      = Dict(
            "codefence" => (LITERATE_JULIA_FENCE => "````")
            ),
        preprocess  = s -> replace(s, r"#hide\s*?\n" => "# hide\n"),
        postprocess = _postprocess_literate_script,
        credit      = getvar(lc, :literate_credits, false),
    )

    # bring back logging level
    Base.CoreLogging._min_enabled_level[] = pre_log_level

    return html(read(ofile, String), lc)
end


"""
    _postprocess_literate_script(s)

Take a markdown string generated by literate and post-process to mark all code
blocks as auto-executed code blocks.
"""
function _postprocess_literate_script(s::String)::String
    isempty(s) && return s
    return replace(s, LITERATE_JULIA_FENCE_R => "````!")
end
